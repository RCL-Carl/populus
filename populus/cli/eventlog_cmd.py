# eventlog sub-command
#
#   This allows the user to see the events that are being
# generated by the running geth instance
#

import click
import os
import os.path
import re
import time

from eth_rpc_client import Client

from .main import main

from populus import utils
from populus.eventlog import EventLogMonitor

from populus.contracts import (
    package_contracts,
)

from populus.geth import (
    get_active_data_dir,
    get_latest_known_instances,
)


def EvtCallback(**kwargs):
    receipt = kwargs["receipt"]
    click.echo(receipt)


@main.command()
@click.option(
    '--contract',
    default="",
    multiple=True,
    metavar="<name>[,<hexaddr>]",
    help=(
        "This parameter is used to filter for events from a particular "
        "contract either by type or by type and address. "
        "The hex value address after the contract is optional. If not "
        "provided then the event log will listen for any events from "
        "any known contract instance of that type in the active chain. "
        "Only the known contracts that are up to date with the latest "
        "code (uses sha512 hash). "
        "User can pass multiple of these options or none. "
        "If no contract options are passed, then the eventlog will listen "
        "to all known objects in the active chain for the current project.\n"
        "Example: --contract Example,0xDEADBEEF"
    ),
)
@click.option(
    '--rpc',
    default="127.0.0.1:8545",
    metavar="<IP>:<PORT>",
    help=(
        "Set the RPC endpoint to which we will listen for events. "
        "Default: 127.0.0.1:8545"
        ),
)
@click.option(
    "--period",
    default=1.0,
    help=(
        "Sets the polling period for the event log monitor in seconds. "
        "Default is 1.0 seconds."
    )
)
@click.option(
    "--active/--no-active",
    default=True,
    help=(
        "This flag indicates whether the attach command will use "
        "the chain that is referenced from the <proj>/chains/.active-chain "
        "to load information about known contracts or not."
    ),
)
def eventlog(contract, rpc, period, active):
    """ Produces a log of events that are generated by contracts.
    """

    project_dir = os.path.abspath(os.getcwd())
    contracts_meta = utils.load_contracts(project_dir)
    contracts = package_contracts(contracts_meta)

    ipStr, port = utils.parse_ipv4_endpoint(rpc)
    client = Client(ipStr, port)

    evtLogger = EventLogMonitor(client, period)

    data_dir = None
    known_cts = {}
    if active:
        data_dir = get_active_data_dir(project_dir)
        if os.path.islink(data_dir):
            known_cts = get_latest_known_instances(contracts, data_dir)
        else:
            click.echo(click.style("No Valid Active Chain Data Directory Found!", fg="red"))

    if len(contract) > 0:
        optRegex = re.compile("(\w+)(,(0x[A-Fa-f0-9]+))?")
        for ctOpt in contract:
            m = optRegex.match(ctOpt)
            if m:
                cname = m.group(1)
                addr = m.group(3)
                if addr is not None:
                    # Add a filter specification by address
                    evtLogger.add_filter(addr, EvtCallback)
                else:
                    # Check for known
                    cts = known_cts[cname]
                    for data in cts:
                        evtLogger.add_filter(data[1], EvtCallback)
    else:
        for ctName in known_cts.keys():
            cts = known_cts[ctName]
            for data in cts:
                evtLogger.add_filter(data[1], EvtCallback)

    click.echo("Event Logger Starting...")

    try:
        while(True):
            evtLogger.poll()
            time.sleep(period)
    except KeyboardInterrupt:
        exit()
